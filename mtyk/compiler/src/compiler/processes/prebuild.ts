import { installNativeDependencies } from "@/compiler/native-dependency";
import { projectPath } from "@/compiler/path";
import { pick } from "@/util/dash";
import { getFilesFromOptionalDirectory } from "@/util/directory";
import fs from "fs";
import fse, { ensureDirSync } from "fs-extra";
import path from "path";
import { PackageJson } from "type-fest";
import bash from "../bash";
import { getBinLocation } from "../bin";
import { getPackageOrg } from "../constants";
import { getBuildContext } from "../context/buildContext";
import { readJSON, writeJSON } from "../json";
import { findModules } from "../module/findModules";
import { getAppInfo } from "../module/getAppInfo";
import { BaseModuleInfo } from "../module/getModuleInfo";
import { initModule } from "../module/initModule";
import { resolveModules } from "../module/resolveModules";
import { safePackages } from "../module/safePackages";
import { OneModuleConfig } from "../one/OneModuleConfig";
import createOneModules from "../one/createOneModules";
import { mergePackageJSON } from "../package/package";
import { createBaseTSConfigs } from "../ts/tsconfig";
import { BUILT_MODULES, getBuiltModulesPath } from "./paths";
const __dirname = path.dirname(new URL(import.meta.url).pathname);

function findParentFolder(pth: string, withSubFolder: string) {
  const subfolders = fs
    .readdirSync(pth)
    .filter((f) => fs.statSync(path.join(pth, f)).isDirectory());
  if (subfolders.includes(withSubFolder)) {
    return path.join(pth, withSubFolder);
  } else {
    if (pth === "/") {
      throw new Error(
        `Could not find parent folder with subfolder ${withSubFolder}`
      );
    } else {
      return findParentFolder(path.join(pth, ".."), withSubFolder);
    }
  }
}

export async function prebuild() {
  const { config } = getBuildContext();
  const resolvedModules = await resolveModules(config);
  const listOfAllModules = findModules();

  const unusedModules = listOfAllModules.filter(
    (module) => !resolvedModules.has(module.name)
  );

  // unlink unused modules
  unusedModules.forEach((module) => {
    fs.lstat(module.path, (err, stats) => {
      if (err) {
        return;
      }

      if (stats.isSymbolicLink()) {
        fs.unlink(module.path, (unlinkErr) => {
          if (unlinkErr) {
            console.error(
              `Error unlinking ${module.path}: ${unlinkErr.message}`
            );
          } else {
            console.log(`Unlinked symbolic link: ${module.path}`);
          }
        });
      }
    });
  });

  const yarnVersion = "4.1.0";
  const releases4Path = projectPath(`.yarn/releases/yarn-${yarnVersion}.cjs`);

  if (!(await fse.pathExists(releases4Path))) {
    const assets = findParentFolder(__dirname, "assets");
    const assetsPath = path.join(assets, `yarn-${yarnVersion}.cjs`);

    // Copy from assets folder
    await fse.copy(assetsPath, releases4Path);
  }

  // Create .yarnrc.yml and set yarn version to 4
  const yarnrcPath = projectPath(".yarnrc.yml");
  const contents = `# Auto-generated by bbuild
compressionLevel: mixed

enableGlobalCache: false
  
nodeLinker: node-modules

yarnPath: .yarn/releases/yarn-${yarnVersion}.cjs`;
  await fse.writeFile(yarnrcPath, contents);

  // Ensure yarn.lock exists
  const yarnLockPath = projectPath("yarn.lock");
  if (!(await fse.pathExists(yarnLockPath))) {
    fs.writeFileSync(yarnLockPath, "");
  }

  // Update/init package.json
  const packageJSONPath = projectPath("package.json");

  const initialJSON: PackageJson = {
    version: "1.0.0",
    private: true,
  };
  const sourceJSON: PackageJson = {
    workspaces: ["modules/*", "apps/*"],
    name: config.name,
    devDependencies: pick(safePackages, ["typescript"]),
    resolutions: {
      "@bbuild/client-modules": `file:./${BUILT_MODULES}/client-modules`,
      "@bbuild/server-modules": `file:./${BUILT_MODULES}/server-modules`,
      ...pick(safePackages, ["nanoid"]),
    },
  };

  const appInfo = await getAppInfo();
  const existingOrNewPackageJSON = (await fse.pathExists(packageJSONPath))
    ? await fse.readJSON(packageJSONPath)
    : initialJSON;

  const updateJSON = mergePackageJSON({
    target: existingOrNewPackageJSON,
    source: sourceJSON,
  });

  for (const app of appInfo) {
    const { packageJSON, packageJSONPath, importedModules } = app;

    let updated = false;
    // check for imported modules in dependencies obj. if not present, add safe version
    for (const mod of importedModules) {
      if (!packageJSON.dependencies[mod] && mod in safePackages) {
        packageJSON.dependencies[mod] = safePackages[mod];
        updated = true;
      } else if (!packageJSON.dependencies[mod] && mod.startsWith("@bbuild")) {
        packageJSON.dependencies[mod] = `workspace:^`;
        updated = true;
      }
    }

    if (updated) {
      await writeJSON(packageJSONPath, packageJSON);
    }
  }

  // If for some wacky reason dist/*.tsbuildinfo exist, and they're directories, delete them
  const distDir = projectPath("dist");
  const distFiles = await getFilesFromOptionalDirectory(distDir);
  for (const file of distFiles) {
    const filePath = path.join(distDir, file);
    const stat = await fse.lstat(filePath);
    if (stat.isDirectory()) {
      console.log(`For some reason ${filePath} is a directory, deleting it.`);
      await fse.rmdir(filePath);
    }
  }

  await writeJSON(packageJSONPath, updateJSON);

  // Find all modules
  const modules = findModules();
  await createBaseTSConfigs(modules);

  // let clientImports: string[] = []
  // let serverImports: string[] = []
  let configs: (OneModuleConfig & BaseModuleInfo)[] = [];
  const org = await getPackageOrg();

  // Prepare tsconfig.jsons
  for (const module of modules) {
    // Create mtyk.config.js
    try {
      const config = await initModule(module);
      configs.push({ ...config, ...module });
      // clientImports = clientImports.concat(config.clientImports)
      // serverImports = serverImports.concat(config.serverImports)
    } catch (e) {
      console.error(`Error initializing module ${module.name}`, e);
    }

    // replace org in dependencies
    const packagePath = path.join(module.path, "package.json");
    const modulePackage: PackageJson = await readJSON(packagePath);

    for (const [key, value] of Object.entries(modulePackage.dependencies)) {
      if (key.includes("@mtyk/") && value === "*") {
        delete Object.assign(modulePackage.dependencies, {
          [key.replace("@mtyk", org)]: modulePackage.dependencies[key],
        })[key];
      }
    }

    await writeJSON(packagePath, modulePackage);
  }

  await installNativeDependencies(modules);

  await createOneModules(configs);

  // For all modules, ensure we create a skeleton built-modules/[module] folder with valid package.json
  // so that the initial yarn install runs
  const moduleDirs = await fse.readdir(projectPath("modules"));
  for (const moduleDir of moduleDirs) {
    // Only if is dir
    const isDir = (
      await fse.stat(projectPath("modules", moduleDir))
    ).isDirectory();
    if (isDir) {
      const packageJSON: PackageJson = {
        name: moduleDir,
        version: "1.0.0",
        private: true,
      };
      await fse.ensureDir(getBuiltModulesPath(moduleDir));
      const packageJSONPath = path.join(
        getBuiltModulesPath(moduleDir),
        "package.json"
      );
      if (!(await fse.pathExists(packageJSONPath))) {
        await writeJSON(packageJSONPath, packageJSON);
      }
      updateJSON["resolutions"] = {
        ...updateJSON["resolutions"],
        [`${await getPackageOrg()}/${moduleDir}`]: `file:./${BUILT_MODULES}/${moduleDir}`,
      };
    }
  }

  // Rewrite package json with resolutions
  await writeJSON(projectPath("package.json"), updateJSON);

  // Init .vscode/extensions.json
  const extensionsJSONPath = projectPath(".vscode/extensions.json");
  const extensionsJSON: { recommendations: string[] } = {
    recommendations: [],
  };
  ensureDirSync(path.dirname(extensionsJSONPath));
  await writeJSON(extensionsJSONPath, extensionsJSON);

  // TODO Init .vscode/settings.json
  // TODO revert back to prettier, biome vscode extension just as buggy...
  // Init biome.json
  // const biomeJSONPath = projectPath("biome.json");
  // const biomeJSON = {
  //   "formatter": {
  //     "enabled": true,
  //     "indentStyle": "space",
  //     "lineWidth": 95,
  //     "indentWidth": 2,
  //     "formatWithErrors": true
  //   },
  //   "linter": {
  //     "enabled": false
  //   },
  //   "organizeImports": {
  //     "enabled": true
  //   },
  //   "javascript": {
  //     "formatter": {
  //       "semicolons": "asNeeded",
  //       "quoteStyle": "single",
  //       "trailingComma": "all",
  //       "arrowParentheses": "always"
  //     }
  //   },
  //   "$schema": "https://biomejs.dev/schemas/1.2.2/schema.json"
  // }
  // await writeJSON(biomeJSONPath, biomeJSON);

  const prettierRCYarml = `
trailingComma: 'es5'
tabWidth: 2
semi: false
singleQuote: true
printWidth: 95
`;
  await fse.writeFile(projectPath(".prettierrc.yml"), prettierRCYarml);

  // Delete rome.json if present
  const romeJSONPath = projectPath("rome.json");
  if (await fse.pathExists(romeJSONPath)) {
    await fse.remove(romeJSONPath);
  }

  await bash`cd ${projectPath()} && yarn`;
  console.log("prebuild finished");
}

export const tsc = getBinLocation("tsc");

export function esm(...args: string[]) {
  return [tsc, "-b", "tsconfig.json", ...args];
}
export function cjs(...args: string[]) {
  return [tsc, "-b", "tsconfig.cjs.json", ...args];
}
